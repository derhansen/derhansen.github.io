---
layout: post
title: Extbase $query->statement() - What can possibly go wrong?
date: '2019-04-01T14:20:00.000+02:00'
author: Torben Hansen
tags:
- wrong results
- repository
- Extbase
- datamapper
modified_time: '2019-04-01T15:29:33.704+02:00'
blogger_id: tag:blogger.com,1999:blog-6517038209122183182.post-2731958449882066714
blogger_orig_url: http://www.derhansen.de/2019/04/extbase-query-statement-what-can-possibly-go-wrong.html
permalink: /2019/04/extbase-query-statement-what-can-possibly-go-wrong.html
---

Last week I had to resolve a problem in a 3rd party Extension, where an Extbase Plugin returned unexpected results when used <i>multiple times</i> on the same page. The problem showed up in the frontend, where the plugin listed some products by a given category. When the plugin was present one time on a page, the output was as following (simplified):<br /><br /><b>Output of plugin 1</b><br />Product 1 for Category 1<br />Product 2 for Category 1<br />Product 3 for Category 1<br /><br />When the plugin was present <b>two times</b> on a page, the output was as following (simplified):<br /><br /><b>Output of plugin 1 with Category 1 as selection criteria</b><br />Product 1 for Category 1 (uid 1)<br />Product 2 for Category 1 (uid 2)<br />Product 3 for Category 1 (uid 3)<br /><div><br /></div><div><b>Output of plugin 2 with&nbsp;</b><b>Category 2 as selection criteria</b><br />Product 1 for Category 2 (uid 10)<br />Product 2 for Category 1 (uid 2) &lt;-- <i><b>Whoops!</b></i><br />Product 3 for Category 2 (uid 11)</div><div><br /></div><div>Somehow, the output of plugin 2 contained a result, that did not belong to the result set. As written, the examples above are simplified. The output on the production website showed hundreds of products, and just some of them were wrong.</div><br />In order to debug the problem, I had a look at the Extbase Repository for the Products Domain model and found this (again simplified).<br /><br /><pre><code><br />class ProductRepository extends \TYPO3\CMS\Extbase\Persistence\Repository<br />{<br />    /**<br />     * @param $categoryUid<br />     * @return array|\TYPO3\CMS\Extbase\Persistence\QueryResultInterface<br />     */<br />    public function findByCategory($categoryUid)<br />    {<br />        $query = $this-&gt;createQuery();<br />        $query-&gt;statement('SELECT * FROM tx_products_domain_model_product_' . $categoryUid);<br />        return $query-&gt;execute();<br />    }<br />}<br /></code></pre><br />OK... so there are several <i>individual tables</i> for products by category. They all have the same structure and the only difference is, that they have a different name (post-fixed with the category uid) and hold different data. There is also a SQL injection vulnerability, but that has nothing to do with the main problem.<br /><br /><h3>What goes wrong here?</h3><div><br /></div>In order to explain, why plugin 2 returns an object, that obviously belongs to plugin 1, you have to know the internals of an <b>Extbase repository,&nbsp;</b>the <b>Extbase QueryResult object </b>and the<b> DataMapper</b>.<br /><br />Extbase determines the <b>Domain Model based on the Classname</b>. This is done in the constructor of the repository like shown below:<br /><pre><code><br />public function __construct(\TYPO3\CMS\Extbase\Object\ObjectManagerInterface $objectManager)<br />{<br />    $this-&gt;objectManager = $objectManager;<br />    $this-&gt;objectType = ClassNamingUtility::translateRepositoryNameToModelName($this-&gt;getRepositoryClassName());<br />}<br /></code></pre><br />So when the <b>findByCategory</b> function uses the <b>createQuery()</b> function, the query is initialized to create a query for the <b>object type</b> the Repository determined (in this case Product).<br /><br />When the query is executed using <b>$query-execute()</b>, it returns an object of the type <b>\TYPO3\CMS\Extbase\Persistence\Generic\QueryResult</b> and here we come closer to the explanation of the problem. The QueryResult object has the following function:<br /><pre><code><br />protected function initialize()<br />{<br />    if (!is_array($this-&gt;queryResult)) {<br />        $this-&gt;queryResult = $this-&gt;dataMapper-&gt;map(<br />            $this-&gt;query-&gt;getType(),<br />            $this-&gt;persistenceManager-&gt;getObjectDataByQuery($this-&gt;query)<br />        );<br />    }<br />}<br /></code></pre><br />This function uses the result from the persistenceManager (raw data from the database with language/workspace overlay) and uses the <b>TYPO3 DataMapper</b> to&nbsp; create an array with Objects of the given type (Product). The DataMapper does this row by row using the following function <b>mapSingleRow($className, array $row)</b><br /><br />And here is the final explanation for the behavior of the 2 plugins on the same page.<br /><pre><code><br />protected function mapSingleRow($className, array $row)<br />{<br />    if ($this-&gt;persistenceSession-&gt;hasIdentifier($row['uid'], $className)) {<br />        $object = $this-&gt;persistenceSession-&gt;getObjectByIdentifier($row['uid'], $className);<br />    } else {<br />        $object = $this-&gt;createEmptyObject($className);<br />        $this-&gt;persistenceSession-&gt;registerObject($object, $row['uid']);<br />        $this-&gt;thawProperties($object, $row);<br />        $this-&gt;emitAfterMappingSingleRow($object);<br />        $object-&gt;_memorizeCleanState();<br />        $this-&gt;persistenceSession-&gt;registerReconstitutedEntity($object);<br />    }<br />    return $object;<br />}<br /></code></pre><br />For performance reasons, the <b>DataMapper caches all objects</b> it creates based on their UID. Since the repository in this TYPO3 extension uses different tables (with own UIDs) for data storage, it may happen, that the <b>DataMapper already processed</b> an object with the given UID (but from a different table) and therefore will return a cached version of an object.<br /><br />So when the output for plugin 1 was created, the DataMapper did create a <b>cached Product object for UID 2</b> and when the output for plugin 2 was created, the DataMapper returned the <b>cached version</b> of the Product object with UID 2.<br /><br />So always keep in mind, that an Extbase repository will return objects of exactly one type and that the datasource must always contain unique uids.<br /><br /><br /><br />