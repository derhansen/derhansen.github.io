---
layout: post
title: TYPO3 Extbase - own validators and multi step form validation using the old
  and new property mapper
date: '2013-05-04T20:05:00.002+02:00'
author: Torben Hansen
tags:
- multiple step form
- old property mapper
- new property mapper
- Extbase
- validation
- own validator
modified_time: '2013-06-01T07:42:28.703+02:00'
thumbnail: http://4.bp.blogspot.com/-WPPcFtZ4dJU/UYEIC1KALqI/AAAAAAAAFKE/gVi9qtydyWI/s72-c/flowchart.png
blogger_id: tag:blogger.com,1999:blog-6517038209122183182.post-3749151667976219851
blogger_orig_url: http://www.derhansen.de/2013/05/typo3-extbase-own-validators-and-multi.html
permalink: /2013/05/typo3-extbase-own-validators-and-multi.html
---

<div>TYPO3 Extbase comes with some standard validators which can be used to validate user input. When working with domain models, you can use those validators to validate the properties of the domain model.</div><div><br /></div><div>When you use Extbase to create a form, where some part of the validation is done through an <b>external API (e.g. logically validation) </b>or<b>&nbsp;</b>you want to validate <b>properties against other properties</b>, the validation process can be more complicated. If you have a multiple step form, where all user input is collected, <i>not persisted</i> and finally sent to an external API which validates the input, it can be even more complicated to <b>"jump back"</b> to the desired step of the multiple step form and output the validation errors of the external API.</div><div><br /></div><div>In this article I will show how to use <b>Extbase validators</b> to validiate a domain model and add <b>several error messages</b> for validation errors at once. I will also show how to display error messages for desired fields in a <b>multiple step form</b> <i>after the validation process via&nbsp;@validate</i> has been performed.<br /><br />Besides this, the article also shows how to create a <b>multiple step form in Extbase</b> and how to handle validation and persistence.</div><div><br />At the time of writing of this article, <b>TYPO3 6.1 with Extbase 6.1</b> was released. In Extbase 6.1, the new property mapper is enabled by default.<br /><br />This article covers both the <b>new</b> and the <b>old property mapper</b>. I have created 2 GitHub repositories, which include all examples for the old and the new property mapper.<br /><ul><li><a href="https://github.com/derhansen/extbase_validation_old_pm" target="_blank">Extbase validation examples for the old property mapper</a></li><li><a href="https://github.com/derhansen/extbase_validation_new_pm" target="_blank">Extbase validation examples for the new property mapper</a></li></ul>The code examples in this article are may be&nbsp;<i>incomplete</i>&nbsp;to save space. Please visit the GitHub repositories mentioned above to see the complete code.<br /><br /><h3>Which property mapper to use - old or new one?</h3>Writing this article, I spent some time with the validation classes of Extbase. Since Extbase 1.4, a lot of things like&nbsp;<i>Tx_Extbase_MVC_Controller_ArgumentError</i> or the <i>$errors array</i> in&nbsp;<i>Tx_Extbase_Validation_Validator_AbstractValidator</i> became <b>deprecated</b> and should be <i>removed in TYPO3 6.0</i>. Well, in TYPO3 6.0, those classed still existed and the deprecation notice now mentioned, that they will be <i>removed in TYPO3 6.1</i>. Some kind of confusing, I thought. Finally, as TYPO3 6.1 came out, the deprecation notice showed, that the deprecated stuff will be removed <i>two versions after TYPO3 6.1</i> (so it will "survive" TYPO3 6.2 LTS). I guess, this is due to keep the backward compatibility to the upcoming LTS version of TYPO3 as high as possible.<br /><br />For those who are unsure which property mapper to use, I recommend the following. If you create a new TYPO3 extension for <b>TYPO3 6.0 or greater</b> - use the <b>new property mapper</b>. It is&nbsp;<a href="http://i%20would%20recommend%20every%20developer%20creating%20a%20new%20extension%20for%20typo3%20%3E%204.7%20to%20use%20the%20new%20property%20mapper./">configurable and extensible</a>&nbsp;and ensures, that you don't use deprecated functions and classes.<br /><br /><br /><h3>Creating an own validator with validation errors for multiple properties</h3></div><div>First I will show you how to create an own validator, which validates a given domain model and is able to add errors for multiple properties. The validator checks, if the given ZIP-code and city-name do match <b>logically</b> (e.g. for the ZIP "20095" the city name must be "Hamburg")</div><div><br /></div><div>Assume you have a domain model "addressdata", which contains fields for a users addressdata. Straight validation like "Empty" or "Numeric" can is implemented in the domain model by using&nbsp;@validate annotations.</div><div><br />To implement the logical validation, I create a new validator in ExtBase.<br /><br /><h4>Old property mapper</h4><pre><code class="php">/**<br /> * Validates the given value<br /> *<br /> * @param mixed $value<br /> *<br /> * @return bool<br /> */<br />public function isValid($value) {<br /> $apiValidationResult = $this-&gt;apiService-&gt;validateAddressData($value);<br /> $success = TRUE;<br /> if ($apiValidationResult['zip']) {<br />  $error = $this-&gt;objectManager-&gt;get('Tx_Extbase_Validation_Error', $apiValidationResult['zip'], time());<br />  $this-&gt;errors['zip'] = $this-&gt;objectManager-&gt;get('Tx_Extbase_Validation_PropertyError', 'zip');<br />  $this-&gt;errors['zip']-&gt;addErrors(array($error));<br />  $success = FALSE;<br /> }<br /> if ($apiValidationResult['city']) {<br />  $error = $this-&gt;objectManager-&gt;get('Tx_Extbase_Validation_Error', $apiValidationResult['city'], time());<br />  $this-&gt;errors['city'] = $this-&gt;objectManager-&gt;get('Tx_Extbase_Validation_PropertyError', 'city');<br />  $this-&gt;errors['city']-&gt;addErrors(array($error));<br />  $success = FALSE;<br /> }<br /> return $success;<br />}<br /></code></pre><h4>New property mapper</h4><pre><code class="php">/**<br /> * Validates the given value<br /> *<br /> * @param mixed $value<br /> * @return bool<br /> */<br />protected function isValid($value) {<br /> $apiValidationResult = $this-&gt;apiService-&gt;validateAddressData($value);<br /> $success = TRUE;<br /> if ($apiValidationResult['zip']) {<br />  $error = $this-&gt;objectManager-&gt;get('TYPO3\\CMS\\Extbase\\Validation\\Error',<br />   $apiValidationResult['zip'], time());<br />  $this-&gt;result-&gt;forProperty('zip')-&gt;addError($error);<br />  $success = FALSE;<br /> }<br /> if ($apiValidationResult['city']) {<br />  $error = $this-&gt;objectManager-&gt;get('TYPO3\\CMS\\Extbase\\Validation\\Error',<br />   $apiValidationResult['city'], time());<br />  $this-&gt;result-&gt;forProperty('city')-&gt;addError($error);<br />  $success = FALSE;<br /> }<br /> return $success;<br />}<br /></code></pre><br /><br />The code above shows, that <b>an external API</b> is used to validate the adress data logically. If the external API returns errors for given fields, errors are manually added for each property to the ExtBase validator.</div><br />To use the newly created validator, you just have to use the&nbsp;<b>@validate annotation</b> in your action like shown below.<br /><br /><h4>Old property mapper</h4><pre><code class="php">/**<br /> * Create action<br /> *<br /> * @param Tx_ValidationExamples_Domain_Model_Addressdata $newAddressdata<br /> * @validate $newAddressdata Tx_ValidationExamples_Validation_Validator_AddressdataValidator<br /> * @return void<br /> */<br />public function createAction(Tx_ValidationExamples_Domain_Model_Addressdata $newAddressdata) {<br /> $this-&gt;addressdataRepository-&gt;add($newAddressdata);<br /> $this-&gt;view-&gt;assign('message', 'Addressdata has been created');<br />}</code></pre><h4>New property mapper</h4><pre><code class="php">/**<br /> * Create action<br /> *<br /> * @param \derhansen\ValidationExamplesNew\Domain\Model\Addressdata $newAddressdata<br /> * @validate $newAddressdata \derhansen\ValidationExamplesNew\Validation\Validator\AddressdataValidator<br /> * @return void<br /> */<br />public function createAction(\derhansen\ValidationExamplesNew\Domain\Model\Addressdata $newAddressdata) {<br /> $this-&gt;addressdataRepository-&gt;add($newAddressdata);<br /> $this-&gt;view-&gt;assign('message', 'Your new Addressdata was created.');<br />}</code></pre><br />The complete source for this example has been tagged in the Github repository. Below follows direct links to the tags.<br /><ul><li><a href="https://github.com/derhansen/extbase_validation_old_pm/tree/example1" target="_blank">Example1 for the old property mapper</a></li><li><a href="https://github.com/derhansen/extbase_validation_new_pm/tree/example1" target="_blank">Example1 for the new property mapper</a></li></ul><h3>Adding custom validation errors in a multiple step form after extbase domain object validation</h3>Sometimes the validation of a form can't be implemented by using @validate annotations. Assume you have a multiple step form, where you just <i>collect user input</i> and validate it using an external API in the last step of your form. <br /><br />There are several approaches to create multiple step forms in Extbase. For this article I use the approach of&nbsp;<b>splitting</b> the main domain model into several small <b>part-domain models</b>, saving them to <b>session variables</b> after each step and consolidate them in the end to the main domain-object which gets persisted.<br /><br />Below is a chart of the multiple step form validation process I'm going to create.<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-WPPcFtZ4dJU/UYEIC1KALqI/AAAAAAAAFKE/gVi9qtydyWI/s1600/flowchart.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="335" src="http://4.bp.blogspot.com/-WPPcFtZ4dJU/UYEIC1KALqI/AAAAAAAAFKE/gVi9qtydyWI/s640/flowchart.png" width="640" /></a></div><br /><br />One advantage of <b>splitting the main domain model</b> to several small part domain models is the fact, that you can use <b>@validation directly</b> in the domain model without caring about the actual step of the form, where you switch validation for single properties on or off.<br /><br />I created a 3 step form to enter some addressdata. The first step requires first- and lastname, the second step requires the street and streetnumber and the third step requires the zip-code and the city. When all form data has been collected, a new addressdata object is persisted to the database.<br /><br />The first version of the multiple step form is tagged in the GitHub repository as example2. It includes the main validation of Extbase and is able to save the form data, when no domain model validation errors are present.<br /><ul><li><a href="https://github.com/derhansen/extbase_validation_old_pm/tree/example2" target="_blank">Example2 for the old property mapper</a></li><li><a href="https://github.com/derhansen/extbase_validation_new_pm/tree/example2" target="_blank">Example2 for the new property mapper</a></li></ul><i>Please note, that the example2-tag for the old property mapper misses <a href="https://github.com/derhansen/extbase_validation_old_pm/commit/05855fe623845081bc8817e8369fffab11c307e1" target="_blank">this code change</a>, which I first discovered after the repository has been tagged.</i><br /><br />Now I've implemented the external API service, which does some logical validation for the given address data.<br /><pre><code class="php"><br />/**<br /> * Simulates validation of addressdata entered in the multiple steps form.<br /> * Returns an array of validation errors for each step of the multiple steps form<br /> *<br /> * @param Tx_ValidationExamples_Domain_Model_Addressdata $addressdata<br /> * @return array<br /> */<br />public function validateMultipleSteps(Tx_ValidationExamples_Domain_Model_Addressdata $addressdata) {<br /> $errors = array();<br /> if ($addressdata-&gt;getStreet() == 'Elbstraße' &amp;&amp; $addressdata-&gt;getStreetnr() &gt; 145) {<br />  $errors['step2']['streetnr'] = 'Streetnr not valid for this street';<br /> }<br /> if ($addressdata-&gt;getZip() == 20095 &amp;&amp; $addressdata-&gt;getCity() != 'Hamburg') {<br />  $errors['step3']['zip'] = 'ZIP Code and city do not match';<br />  $errors['step3']['city'] = 'ZIP Code and city do not match';<br /> }<br /> return $errors;<br />}<br /></code></pre><br />The call to the API service is implemented in the createAction() for the form. If the API service returns errors for some fields, then the createAction() saves the <b>validation result to a session variable</b> and <b>redirects</b> the user to the <b>desired step</b> in the multiple step form.<br /><br />In the action for the given step, I've implemented a check for the validation results of the API service. This check <b>sets validation errors</b> to the given properties of the domain model. If there already are validation errors for the domain model, the new ones from the external API validation are added.<br /><br /><h4>Old property mapper</h4><pre><code class="php"><br />/**<br /> * Sets validation errors for fields in the given step<br /> *<br /> * @param string $step The step<br /> * @return void<br /> */<br />protected function setApiValidationErrors($step) {<br /> $apiresults = $GLOBALS['TSFE']-&gt;fe_user-&gt;getKey('ses', 'apiresults');<br /> if (array_key_exists($step, $apiresults)) {<br />  /* Set Form Errors manually */<br />  $origErrors = $this-&gt;controllerContext-&gt;getRequest()-&gt;getErrors();<br />  if ($origErrors) {<br />   $errors = $origErrors[$step . 'data'];<br />  } else {<br />   $errors = $this-&gt;objectManager-&gt;get('Tx_Extbase_MVC_Controller_ArgumentError' ,$step . 'data');<br />  }<br /><br />  $propertyErrors = array();<br /><br />  /* Add validation errors */<br />  foreach ($apiresults[$step] as $key =&gt; $value) {<br />   $propertyErrors[$key] = $this-&gt;objectManager-&gt;get('Tx_Extbase_Validation_PropertyError', $key);<br />   $message = $apiresults[$step][$key];<br />   $propertyError = $this-&gt;objectManager-&gt;get('Tx_Extbase_Validation_Error', $message, time());<br />   $propertyErrors[$key]-&gt;addErrors(array($propertyError));<br />  }<br />  $errors-&gt;addErrors($propertyErrors);<br /><br />  $this-&gt;controllerContext-&gt;getRequest()-&gt;setErrors(array($errors));<br /> }<br />}<br /></code></pre><h4>New property mapper</h4><pre><code class="php"><br />/**<br /> * Sets validation errors for fields in the given step<br /> *<br /> * @param string $step The step<br /> * @return void<br /> */<br />protected function setApiValidationErrors($step) {<br /> $apiresults = $GLOBALS['TSFE']-&gt;fe_user-&gt;getKey('ses', 'apiresults');<br /> if (array_key_exists($step, $apiresults)) {<br />  /* Set Form Errors manually  - get results from property mapper and add new errors */<br />  $result = $this-&gt;getControllerContext()-&gt;getRequest()-&gt;getOriginalRequestMappingResults();<br /><br />  /* Add validation errors */<br />  foreach ($apiresults[$step] as $key =&gt; $value) {<br />   $error = $this-&gt;objectManager-&gt;get('TYPO3\\CMS\\Extbase\\Validation\Error',<br />    $apiresults[$step][$key], time());<br />   $result-&gt;forProperty($step . 'data.' . $key)-&gt;addError($error);<br />  }<br />  $this-&gt;getControllerContext()-&gt;getRequest()-&gt;setOriginalRequestMappingResults($result);<br /> }<br />}<br /></code></pre><div><br /></div>Since the code above is specially made for handling multiple steps / fields (like this example), below follows a more common example which shows how to set a validation error for a special property of a domain object.<br /><br /><h4>Old property mapper</h4><pre><code class="php"><br />/* Set validation error for property */<br />$errors = $this-&gt;objectManager-&gt;get('Tx_Extbase_MVC_Controller_ArgumentError', 'addressdata'); <br /><br />$propertyErrors = array();<br /><br />$propertyErrors['streetnr'] = $this-&gt;objectManager-&gt;get('Tx_Extbase_Validation_PropertyError', 'streetnr');<br />$message = 'Validation message for streetnr';<br />$propertyError = $this-&gt;objectManager-&gt;get('Tx_Extbase_Validation_Error', $message, time());<br />$propertyErrors['streetnr']-&gt;addErrors(array($propertyError));<br /><br />$errors-&gt;addErrors($propertyErrors);<br /><br />$this-&gt;controllerContext-&gt;getRequest()-&gt;setErrors(array($errors));<br /></code></pre><h4>New property mapper</h4><pre><code>$result = $this-&gt;getControllerContext()-&gt;getRequest()-&gt;getOriginalRequestMappingResults();<br />$error = $this-&gt;objectManager-&gt;get('TYPO3\\CMS\\Extbase\\Validation\Error', 'Validation message for streetnr', time());<br />$result-&gt;forProperty('addressdata.streetnr')-&gt;addError($error);<br />$this-&gt;getControllerContext()-&gt;getRequest()-&gt;setOriginalRequestMappingResults($result);<br /></code></pre><br />This code adds an error for the domain object "addressdata" and sets a single validation message for the property "streetnr".<br /><br />The final version of the multiple step form is tagged in the GitHub repository as example3.<br /><ul><li><a href="https://github.com/derhansen/extbase_validation_old_pm/tree/example3" target="_blank">Example3 for the old property mapper</a></li><li><a href="https://github.com/derhansen/extbase_validation_new_pm/tree/example3" target="_blank">Example3 for the new property mapper</a></li></ul><h3>Conclusion</h3>Using the techniques shown above gives you flexibility when working with Extbase and external validation services. It also shows how to set validation errors for multiple properties at once and how to control validation results after the property mapper has processed domain validation.<br /><br />As you may have noticed, the examples for the <b>new property mapper</b> in Extbase look <b>more clear</b>, contains <b>lesser code</b> and are better <b>readable</b>, since it does not use arrays to collect validation errors but <b>objects</b>.<br /><br /><br />