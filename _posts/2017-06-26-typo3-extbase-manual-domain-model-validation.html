---
layout: post
title: TYPO3 Extbase - Manual validation of a domain model
date: '2017-06-26T11:01:00.000+02:00'
author: Torben Hansen
tags:
- property mapper
- Extbase
- validation
- TYPO3
- domain model
modified_time: '2017-06-26T11:01:10.501+02:00'
blogger_id: tag:blogger.com,1999:blog-6517038209122183182.post-5256957343753052897
blogger_orig_url: http://www.derhansen.de/2017/06/typo3-extbase-manual-domain-model-validation.html
permalink: /2017/06/typo3-extbase-manual-domain-model-validation.html
---

When you create an Extbase extension and allow a website user to submit form data that will be saved to the TYPO3 database, you usually work with validators in your domain model to ensure, that the given data will match certain criteria (e.g. properties have the right data type or expected data format). Extbase offers an easy way to add validation rules to domain model properties, by just adding the <b>@validate</b> annotation followed by one or multiple validators as shown in the following example:<br /><pre><code><br />/**<br /> * Description<br /> *<br /> * @var string<br /> * @validate NotEmpty, StringLength(minimum=10, maximum=50)<br /> */<br />protected $description = '';<br /></code></pre><br />Extbase will take care of the domain model validation, when the given form data is converted to an object of the type TYPO3\CMS\Extbase\Mvc\Controller\Argument.<br /><br /><h3>Manual validation</h3><br />If you manually create a domain model object and want to make sure, that your Extbase validation rules are meet, you can trigger the domain model validation manually as shown below:<br /><pre><code><br />/** @var Data $dataModel */<br />$dataModel = $this-&gt;objectManager-&gt;get(Data::class);<br />$dataModel-&gt;setDescription('too short');<br /><br />/* @var $validator \TYPO3\CMS\Extbase\Validation\Validator\ConjunctionValidator */<br />$validator = $this-&gt;objectManager-&gt;get(ValidatorResolver::class)-&gt;getBaseValidatorConjunction(Data::class);<br />$validationResults = $validator-&gt;validate($dataModel);<br /><br />if ($validationResults-&gt;hasErrors()) {<br />    // @todo cycle through errors in $validationResults-&gt;getFlattenedErrors()<br />}<br /></code></pre><br />By creating the domain model object manually, you must take into account, that this will create a new object, where all properties are initialized with the <b>default values</b> defined in the domain model.<br /><br /><h3>Practical use case</h3><br />As an example for a practical use case for manual domain model validation, lets assume you have a REST webservice and need to import some data to TYPO3. You typically fetch the data from the webservice and add the data to the database. Instead of checking the content of the incoming record/field manually using if-statements, you can use the <b>Extbase property mapper</b> in combination with <b>manual domain model validation</b>.<br /><br />Below follows some example code for the described use case:<br /><pre><code><br />/** @var PropertyMapper $propertyMapper */<br />$propertyMapper = $this-&gt;objectManager-&gt;get(PropertyMapper::class);<br /><br />// Get some data - could for example be some data from a REST webservice<br />$data = $this-&gt;getApiData();<br /><br />foreach ($data as $importRecord) {<br />    $dataModel = $propertyMapper-&gt;convert($importRecord, Data::class);<br />    // Note: The propertyMapper will set domain model default values for all all non-mappable values<br /><br />    /* @var $validator \TYPO3\CMS\Extbase\Validation\Validator\ConjunctionValidator */<br />    $validator = $this-&gt;objectManager-&gt;get(ValidatorResolver::class)-&gt;getBaseValidatorConjunction(Data::class);<br />    $validationResults = $validator-&gt;validate($dataModel);<br /><br />    if ($validationResults-&gt;hasErrors()) {<br />        // Record could not be imported, collect error messages for each field in $errorMessages array<br /><br />        /** @var Error $error */<br />        foreach ($validationResults-&gt;getFlattenedErrors() as $field =&gt; $errors) {<br />            $errorMessages = [];<br />            foreach ($errors as $error) {<br />                $errorMessages[] = $error-&gt;getMessage();<br />            }<br />        }<br />    } else {<br />        // Import record to repository...<br />    }<br />}<br /></code></pre><br />By using the Extbase property mapper to create domain model objects, you do not need to check and assign each field individually. You just have to make sure, that the array given passed to the "convert" function use the same field naming as the domain model do like shown below.<br /><br /><pre><code><br />'title' =&gt; 'a title',<br />'email' =&gt; 'torben@derhansen.com',<br />'description' =&gt; 'a description',<br />'year' =&gt; 2017,<br />'amount' =&gt; 19.99,<br />'paid' =&gt; true<br /></code></pre><br />Note, that the resulting object from the property mapper will contain the <b>default values</b> for each property, that can't be mapped properly.<br /><br />In the code example above, the resulting domain model object will manually be validated and if no validation errors occur, the object can be added to the repository.<br /><br />I created a small <a href="https://github.com/derhansen/manual_domainvalidation" target="_blank">demo extension</a> with a command controller, which contains 2 example commands that show validation results for some dummy data.